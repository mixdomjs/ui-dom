var e,t,o;(e=>{e[e.Data=1]='Data',e[e.Actions=2]='Actions',e[e.Otherwise=4]='Otherwise',e[e.DoRefresh=8]='DoRefresh',e[e.NoRefresh=16]='NoRefresh',e[e.Contextual=3]='Contextual',e[e.All=7]='All'})(e||(e={})),(e=>{e[e.Cascading=1]='Cascading',e[e.Parent=2]='Parent',e[e.Overridden=4]='Overridden',e[e.All=7]='All'})(t||(t={})),(e=>{e[e.always=-2]='always',e[e.deep=-1]='deep',e[e.changed=0]='changed',e[e.shallow=1]='shallow',e[e.double=2]='double'})(o||(o={}));const n={range(e,t,o=1){'number'!=typeof t&&([t,e]=[e,0]);const n=[];if(t<e)for(let s=e-1;s>=t;s-=o)n.push(s);else for(let s=e;s<t;s+=o)n.push(s);return n},buildRecordable(e){if(e.constructor===Object)return e;const t={};for(const o of e)t[o]=!0;return t},refreshWithTimeout(e,t,o,n,s){null!==o&&void 0!==s&&(window.clearTimeout(o),o=null);const i=void 0===s?n:s;return null===i?t.call(e):null===o&&(o=window.setTimeout((()=>t.call(e)),i)),o},cleanHtmlProps(e,t){const o=t?Object.assign({},e):e;return o.className&&(o.class=o.class?o.class+' '+o.className:o.className),delete o.className,'string'==typeof o.style&&(o.style=n.cleanHtmlStyle(o.style)),o},cleanHtmlStyle(e){const t=e.replace(/\/\*(.|\s)*?\*\//g,' ').replace(/\s+/g,' ').trim();if(!t)return{};const o={},n=t.split(';').map((e=>e.split(':').map((e=>e&&e.trim()))));for(const[e,t]of n)e&&(o[e.replace(/\W+\w/g,(e=>e.slice(-1).toUpperCase()))]=t);return o},cleanHtmlClass(...e){const t={};for(const o of e)o&&n.collectNamesTo(o,t,' ');return Object.keys(t).join(' ')},collectNamesTo(e,t,o=''){switch(typeof e){case'string':if(o)for(const n of e.split(o))n&&(t[n]=!0);else t[e]=!0;break;case'object':if(e.constructor===Object)for(const o in e)o&&e[o]&&(t[o]=!0);else for(const n of e)if(n&&'string'==typeof n)if(o)for(const e of n.split(o))e&&(t[e]=!0);else t[n]=!0}},getClassNameDiffs(e,t){if((e=e||'')===(t=t||''))return null;const o=e.split(' '),n=t.split(' '),s={};let i=null;if(o)for(const e of o)!e||n&&-1!==n.indexOf(e)||(s[e]=i=!1);if(n)for(const e of n)!e||o&&-1!==o.indexOf(e)||(s[e]=i=!0);return null!==i?s:null},getDictionaryDiffs(e,t,o){const n={};for(const o in e){void 0!==e[o]&&void 0===t[o]&&(n[o]=void 0)}for(const o in t){const s=t[o];e[o]!==s&&(n[o]=s)}if(o)for(const e of o)delete n[e];for(const e in n)return n;return null},equalDomProps(e,t){if(e.style){if(!t.style)return!1;const o=e.style,n=t.style;for(const e in n)if(o[e]!==n[e])return!1;for(const e in o)if(void 0===n[e]&&void 0!==o[e])return!1}else if(t.style)return!1;for(const o in t)if(e[o]!==t[o]&&'style'!==o)return!1;for(const o in e)if(void 0===t[o]&&void 0!==e[o]&&'style'!==o)return!1;return!0},areEqual(e,t,o=-1){if(e===t)return!0;if(e&&o&&'object'==typeof e){if(!t||'object'!=typeof t)return!1;const s=e.constructor;if(s!==t.constructor)return!1;o--;let i=!1;switch(s){case Object:break;case Array:i=!0;break;case Set:i=!0,e=[...e],t=[...t];break;case Map:if(e.size!==t.size)return!1;for(const[s,i]of e){if(!t.has(s))return!1;if(o?!n.areEqual(t.get(s),i,o):t.get(s)!==i)return!1}return!0;default:const s=e.toString();'[object NodeList]'!==s&&'[object HTMLCollection]'!==s||(i=!0)}if(i){const s=e.length;if(s!==t.length)return!1;for(let i=0;i<s;i++)if(o?!n.areEqual(e[i],t[i],o):e[i]!==t[i])return!1}else{for(const s in t){if(!e.hasOwnProperty(s))return!1;if(o?!n.areEqual(e[s],t[s],o):e[s]!==t[s])return!1}for(const o in e)if(!t.hasOwnProperty(o))return!1}return!0}return!1}};var s=(e,t)=>{var o={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(null!=e&&'function'==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(e);s<n.length;s++)t.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(e,n[s])&&(o[n[s]]=e[n[s]])}return o};const i={getDefType(e){if('string'==typeof e)return'dom';const t=e.UI_DOM_TYPE;if(!t)return'function'==typeof e?'boundary':'';switch(t){case'Live':case'Mini':case'Wired':return'boundary';case'Spread':case'Fragment':case'Portal':case'Element':case'Contexts':case'Host':return t.toLowerCase();default:return''}},createDef(e='div',t=null,...o){const r=i.getDefType(e);if(!r)return null;const d=[];let a=!1,c=0;for(const e of o){let t='string'==typeof e;if(e&&t&&a){d[c-1].domContent+=e;continue}const o=i.createDefFromContent(e);o&&(c=d.push(o),a=t)}if('spread'===r)return e.unfold(t||{},d);if('fragment'===r&&!d[0])return null;const u='dom'===r&&e||'boundary'===r&&e||'element'===r&&'_'||('content'===r?'':null),l={_uiDefType:r,tag:u,childDefs:d},h=!!u;if('fragment'===l._uiDefType)t&&void 0!==t.withContent&&(l.withContent=t.withContent);else if(t){const{key:e,ref:o,contexts:i}=t,d=s(t,['key','ref','contexts']);if(null!=e&&(l.key=e),o){const e=[];if('Ref'===o.constructor.UI_DOM_TYPE)e.push(o);else for(const t of o)t&&'Ref'===t.constructor.UI_DOM_TYPE&&-1===e.indexOf(t)&&e.push(t);l.attachedRefs=e}i&&'boundary'===r&&(l.attachedContexts=Object.assign({},i)),h&&(l.props='string'==typeof u?n.cleanHtmlProps(d):d)}else h&&(l.props={});switch(l._uiDefType){case'portal':{const e=t||{};l.domPortal=e.container||null,!d[0]&&e&&null!=e.content&&(o=[e.content]);break}case'contexts':l.contexts=(t||{}).cascade||null;break;case'element':{const e=t||{};l.domElement=e.element||null,l.domCloneMode=null!=e.cloneMode?'boolean'==typeof e.cloneMode?e.cloneMode?'deep':'':e.cloneMode:null,delete l.props.element,delete l.props.cloneMode;break}}return l},createDefFromContent(e){if(e&&'object'==typeof e){if('string'==typeof e._uiDefType)return e;if(e instanceof Node)return{_uiDefType:'content',tag:'',childDefs:[],domContent:e};if('Host'===e.constructor.UI_DOM_TYPE)return{_uiDefType:'host',tag:null,host:e,key:e,childDefs:[]};if(Array.isArray(e)||e instanceof HTMLCollection||e instanceof NodeList){const t=[...e].map((e=>i.createDefFromContent(e))).filter((e=>e));return t.length?{_uiDefType:'fragment',tag:null,isArray:!0,childDefs:t}:null}e=String(e)}return null!=e?{_uiDefType:'content',tag:'',domContent:e,childDefs:[]}:null},newAppliedDefBy(e,t){const o={_uiDefType:e._uiDefType,tag:e.tag,key:e.key,childDefs:[],action:'mounted'};return'fragment'===o._uiDefType?(e.isArray&&(o.isArray=!0),e.scopeType&&(o.scopeType=e.scopeType)):'pass'===o._uiDefType?o.contentPass=t||null:e.host&&(o.host=e.host),o},newContentPassDef(e,t){const o={_uiDefType:'pass',tag:null,childDefs:[],contentPassType:t?'copy':'pass'};return null!=e?o.key=e:t||(o.key=i.ContentKey),o},newContentCopyDef:e=>i.newContentPassDef(e,!0),ContentKey:{}},r={boundariesWithin(e,t=!0){const o=[];let n,s=[e],i=0;for(;n=s[i];)i++,null!==n.isMounted&&(o.push(n),(t||e===n)&&n.innerBoundaries[0]&&(s=n.innerBoundaries.concat(s.slice(i)),i=0));return o},treeNodesWithin(e,t,o=0,n=!1,s=!1,i){const r=[];let d,a=[e],c=0;const u=e.boundary;for(;d=a[c];)if(c++,!d.boundary||null!==d.boundary.isMounted){if((!t||t[d.type])&&(!i||i(d))){const e=r.push(d);if(o&&e>=o)return r}d.boundary&&!n&&d.boundary!==u||('host'!==d.type||s)&&d.children[0]&&(a=d.children.concat(a.slice(c)),c=0)}return r},rootDomTreeNodes(e,t=!1,o=!1,n=0){let s=[];for(const i of e.children)if(i.domNode||o)switch(i.type){case'dom':if(s.push(i),n&&s.length>=n)return s;break;case'boundary':case'pass':case'host':if(!t)break;case'contexts':case'root':if(s=s.concat(r.rootDomTreeNodes(i,t,o,n-s.length)),n&&s.length>=n)return s.slice(0,n)}return s},findTreeNodes:(e,t,o=0,s=!1,i=!1,d)=>r.treeNodesWithin(e,n.buildRecordable(t),o,s,i,d),domElementByQuery(e,t,o=!1,n=!1){const s=r.treeNodesWithin(e,{dom:!0},1,o,n,(e=>e.domNode&&e.domNode instanceof Element&&e.domNode.matches(t)))[0];return s&&s.domNode||null},domElementsByQuery:(e,t,o=0,n=!1,s=!1)=>r.treeNodesWithin(e,{dom:!0},o,n,s,(e=>e.domNode&&e.domNode instanceof Element&&e.domNode.matches(t))).map((e=>e.domNode))};class d{constructor(e){}}d.UI_DOM_TYPE='Fragment';class a{constructor(e){}}a.UI_DOM_TYPE='Portal';class c{constructor(e){}}c.UI_DOM_TYPE='Element';class u{constructor(e){}static unfold(e,t){return null}static unfoldWith(e,t){const o={_uiDefType:'fragment',childDefs:[e],scopeType:'spread',tag:null};let n,s=[[e,o]],i=!1,r=0;for(;n=s[r];){r++;let e=n[0];const o=n[1];if('fragment'===e._uiDefType&&e.withContent){const n=Object.assign({},e);delete n.withContent,t.length||(n.childDefs=[]),o.childDefs[o.childDefs.indexOf(e)]=n,e=n}if('pass'===e._uiDefType){const n={_uiDefType:'fragment',tag:null,childDefs:[...t]};null!=e.key&&(n.key=e.key),i||'copy'===e.contentPassType?n.scopeType='spread-copy':(n.scopeType='spread-pass',i=!0),o.childDefs[o.childDefs.indexOf(e)]=n}else if(e.childDefs[0]){const t=[];for(const o of e.childDefs)t.push([o,e]);s=t.concat(s.slice(r)),r=0}}return o}}u.UI_DOM_TYPE='Spread';const l=e=>{var t;return(t=class e extends u{static unfold(t,o){const n=i.createDefFromContent(e.render(t));return n&&e.unfoldWith(n,o)}}).render=e,t};function h(e){var t;return(t=class extends e{constructor(...e){super(...e),this.treeNodes=new Set}getTreeNode(){return[...this.treeNodes][this.treeNodes.size-1]||null}getTreeNodes(){return[...this.treeNodes]}getDomNode(e=!1){let t=this.treeNodes.size-1;const o=[...this.treeNodes];for(;t>=0;){const n=o[t];if(n.domNode&&(!e||'dom'===n.type))return n.domNode}return null}getDomNodes(e=!1){let t=[];for(const o of this.treeNodes)o.domNode&&('dom'===o.type?t.push(o.domNode):e||(t=t.concat(r.rootDomTreeNodes(o,!0).map((e=>e.domNode)))));return t}getRefBoundary(){const e=[...this.treeNodes][this.treeNodes.size-1];return e&&'boundary'===e.type&&e.boundary||null}getRefBoundaries(){const e=[];for(const t of this.treeNodes)'boundary'===t.type&&t.boundary&&e.push(t.boundary);return e}static didAttachOn(e,t){e.treeNodes.has(t)||(e.treeNodes.add(t),'dom'===t.type?e.domDidAttach&&t.domNode&&e.domDidAttach(t.domNode):'boundary'===t.type&&e.uiDidAttach&&t.boundary&&e.uiDidAttach(t.boundary))}static willDetachFrom(e,t){e.treeNodes.has(t)&&('dom'===t.type?e.domWillDetach&&t.domNode&&e.domWillDetach(t.domNode):'boundary'===t.type&&e.uiWillDetach&&t.boundary&&e.uiWillDetach(t.boundary)),e.treeNodes.delete(t)}}).UI_DOM_TYPE='Ref',t}class f extends(h(Object)){}const p=()=>new f,m=h;function y(e){var t;return(t=class extends e{constructor(e,t=null,...o){super(...o),this.props=e,this.updateMode=t}setUpdateMode(e){this.updateMode=e}render(e){return se.Content}isMounted(){return!1}getChildren(e=!1,t=!0){return[]}needsChildren(e){}}).UI_DOM_TYPE='Mini',t}class g extends(y(Object)){}const D=e=>function(t){return e(this,t)},v=y;class C extends g{constructor(e,t=null){super(e,t)}static refresh(e,t,o){}static update(e,t){}static setProps(e,t,o,n){}static getAddedProps(){return{}}static getMixedProps(e){return{}}render(){return te}}C.UI_DOM_TYPE='Wired';const x=(e,t,o,...n)=>{var s;return(s=class e extends C{static getAddedProps(){return e.builder?e.builder(e.props,...n):e.props}static getMixedProps(t){return e.mixer?e.mixer(t,e.props,...n):Object.assign(Object.assign({},t),e.props)}static refresh(t=!0,o,n){e.setProps(this.getAddedProps(),t,o,n)}static update(t,o){for(const n of e.uiBoundaries)n.update(!0,t,o)}static setProps(t,o=!0,n,s){this.props===t&&'force'!==o&&void 0===n&&void 0===s||(e.props=t,o&&e.update(n,s))}render(){return i.createDef(e.source,e.getMixedProps(this.props),te)}}).UI_DOM_TYPE='Wired',s.uiBoundaries=new Set,s.source=e,s.builder='object'!=typeof t&&t||null,s.mixer=o||null,s.props=t?'object'==typeof t?t:t(null,...n):{},s.updateMode='always',s};function N(e){var o;return(o=class extends e{constructor(e,t,...o){super(...o),t&&(this.uiBoundary=t,t.live=this),this.uiWired=null,this.props=e,this.updateModes={}}update(e,t,o){this.uiBoundary.uiHost.services.absorbUpdates(this.uiBoundary,{force:e||!1},t,o)}setState(e,t,o,n){const s=Object.assign(Object.assign({},this.state),e);this.uiBoundary.updateBy({state:s},t,o,n)}setInState(e,t,o,n,s){const i=Object.assign(Object.assign({},this.state||{}),{[e]:t});this.uiBoundary.updateBy({state:i},o,n,s)}addTimer(e,t,o,n=!0){this.timers?this.timers.has(e)&&this.clearTimer(e):this.timers=new Map,this.timers.set(e,window.setTimeout((()=>{this.clearTimer(e),n?t.call(this):t()}),o))}hasTimer(e){return!!this.timers&&this.timers.has(e)}clearTimer(e){if(!this.timers)return;const t=this.timers.get(e);null!=t&&(window.clearTimeout(t),this.timers.delete(e))}clearTimers(e){if(this.timers)if(e)for(const t of e)this.clearTimer(t);else this.timers.forEach((e=>window.clearTimeout(e))),this.timers.clear()}isMounted(){return!0===this.uiBoundary.isMounted}queryDomElement(e,t=!1,o=!1){return r.domElementByQuery(this.uiBoundary.treeNode,e,t,o)}queryDomElements(e,t=0,o=!1,n=!1){return r.domElementsByQuery(this.uiBoundary.treeNode,e,t,o,n)}findDomNodes(e=0,t=!1,o=!1,n){return r.treeNodesWithin(this.uiBoundary.treeNode,{dom:!0},e,t,o,n).map((e=>e.domNode))}findBoundaries(e=0,t=!1,o=!1,n){return r.treeNodesWithin(this.uiBoundary.treeNode,{boundary:!0},e,t,o,n).map((e=>e.boundary))}findTreeNodes(e,t=0,o=!1,s=!1,i){return r.treeNodesWithin(this.uiBoundary.treeNode,n.buildRecordable(e),t,o,s,i)}getChildren(e=!1,t=!0){return this.uiBoundary.contentApi&&this.uiBoundary.contentApi.getChildren(e,t)||[]}needsChildren(e){this.uiBoundary.contentApi&&this.uiBoundary.contentApi.needsChildren(e)}needsData(e,t,o){return this.uiBoundary.contextApi.needsData(e,t,o)}needsDataBy(e,t,o){return this.uiBoundary.contextApi.needsDataBy(e,t,o)}needsAction(e,t,o){this.uiBoundary.contextApi.needsAction(e,t,o)}needsActions(e,t=[],o){this.uiBoundary.contextApi.needsActions(e,t,o)}needsActionsBy(e,t,o){this.uiBoundary.contextApi.needsActionsBy(e,t,o)}setData(e,t,o,n,s){const i=this.uiBoundary.contextApi.getContext(e);i&&i.setData(t,o,n,s)}setInData(e,t,o,n,s,i){const r=this.uiBoundary.contextApi.getContext(e);r&&r.setInData(t,o,n,s,i)}getData(e,t){const o=this.uiBoundary.contextApi.getContext(e);return o?o.data:t}getInData(e,t,o){const n=this.uiBoundary.contextApi.getContext(e);return n?n.getInData(t):o}refreshData(e,t,o){const n=this.uiBoundary.contextApi.getContext(e);n&&n.refresh(t,o)}refreshDataBy(e,t){const o=this.uiBoundary.contextApi.getContexts(e);for(const n in o){const s=o[n];s&&s.refresh(e[n],t)}}sendAction(e,t,o,n){const s=this.uiBoundary.contextApi.getContext(e);s&&s.sendAction(t,o,n)}sendActionWith(e,t,o,n,s){const i=this.uiBoundary.contextApi.getContext(e);i&&i.sendAction({type:t,payload:o},n,s)}askQuestion(e,t,o){const n=this.uiBoundary.contextApi.getContext(e);return n?n.askQuestion(t,o):void 0===o?t.value:o}askQuestionWith(e,t,o,n,s=0){const i=this.uiBoundary.contextApi.getContext(e);return i?i.askQuestion({type:t,payload:o,value:n},s):[]}askQuestionary(e,t,o=0){const n=this.uiBoundary.contextApi.getContext(e);return n?n.askQuestionary(t,o):t.values||[]}askQuestionaryWith(e,t,o,n=0){const s=this.uiBoundary.contextApi.getContext(e);return s?s.askQuestionary({type:t,payload:o,values:[]},n):[]}hasContext(e,o=t.All){return!!this.uiBoundary.contextApi.getContext(e,o)}getContext(e,o=t.All){return this.uiBoundary.contextApi.getContext(e,o)}getContexts(e,t){return this.uiBoundary.contextApi.getContexts(e,t)}overrideContext(e,t,o=!0){this.uiBoundary.contextApi.overrideContext(e,t,o)}overrideContexts(e,t=!0){this.uiBoundary.contextApi.overrideContexts(e,t)}createContext(e,t,o=!0){const n=se.createContext(e);return t&&this.uiBoundary.contextApi.overrideContext(t,n,o),n}createContexts(e,t=!1,o=!0){const n=se.createContexts(e);return t&&this.uiBoundary.contextApi.overrideContexts(n,o),n}createWired(e,t,o,...n){const s=se.createWired(e,t,o,...n);return this.uiWired?this.uiWired.add(s):this.uiWired=new Set([s]),s}render(){return se.Content}}).UI_DOM_TYPE='Live',o}class T extends(N(Object)){constructor(e,...t){super(e,...t)}}const b=e=>(t,o)=>e(o,t),B=e=>(t,o)=>e(o,t),_=N;var A=(e,t)=>{var o={};for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.indexOf(n)<0&&(o[n]=e[n]);if(null!=e&&'function'==typeof Object.getOwnPropertySymbols){var s=0;for(n=Object.getOwnPropertySymbols(e);s<n.length;s++)t.indexOf(n[s])<0&&Object.prototype.propertyIsEnumerable.call(e,n[s])&&(o[n[s]]=e[n[s]])}return o};class M{constructor(e){this.settings=e,this.externalElements=new Set}getApprovedNode(e,t){let o=e;const n=null!=t.def.domCloneMode?t.def.domCloneMode:this.settings.duplicateDomNodeBehaviour;return('always'===n||this.externalElements.has(e))&&(o=this.settings.duplicateDomNodeHandler?this.settings.duplicateDomNodeHandler(e,t):n?e.cloneNode('deep'===n||'always'===n):null),o&&this.externalElements.add(o),o}createDomNodeBy(e){const t=e.def.tag;if('string'!=typeof t)return null;if('_'===t)return e.def.domElement&&this.getApprovedNode(e.def.domElement,e)||null;const o=e.def.domContent;if(o instanceof Node)return this.getApprovedNode(o,e);if(e.def.domHtmlMode&&null!=o&&''!==o)return M.domNodeFrom(o.toString(),t||this.settings.renderHtmlDefTag,!0);if(t)return'svg'===t||e.parent&&e.parent.domNode&&void 0!==e.parent.domNode.ownerSVGElement?document.createElementNS(this.settings.renderSvgNamespaceURI||'http://www.w3.org/2000/svg',t):document.createElement(t);let n=null,s='',i='';if(null!=o){i=(this.settings.renderTextContent?this.settings.renderTextContent(o):o).toString();const e=this.settings.renderTextTag;if(e)if('string'==typeof e)s=e;else if('function'==typeof e){const t=e(o);t instanceof Node&&(n=t)}}return n||(n=s?document.createElement(s):document.createTextNode(i)),s&&i&&(n.textContent=i),n}applyToDom(e){const t=[];let o=null;const n=[];this.settings.devLogRenderInfos&&console.log('__UIRender.applyToDom: Dev-log: Received rendering infos: ',e);for(const s of e){const e=s.treeNode;if(s.remove){if('dom'===e.type&&e.domNode){const n=e.domNode,s=n.parentNode,i=e.def.attachedRefs;let r=!1;if(i)for(const t of i)t&&t.domWillUnmount&&t.domWillUnmount(n)&&(r=!0),f.willDetachFrom(t,e);r?o?o.push(n):o=[n]:!s||-1!==t.indexOf(s)||o&&o.some((e=>e.contains(n)))||s.removeChild(n);const d='element'===e.def._uiDefType;(d||'content'===e.def._uiDefType)&&this.externalElements.delete(n),d||t.push(n),e.domNode=null,M.updateDomChainBy(e,null)}continue}let i=!1,r=!1;if(s.refresh&&e.domNode&&e.domProps&&(e.domProps='read'===s.refresh?M.readFromDom(e.domNode):{},i=!0),s.create)switch(e.type){case'dom':const t=this.createDomNodeBy(e);t&&(e.domNode=t,r=!0);break;case'portal':e.domNode=e.def.domPortal||null}if(r||s.move)if('host'===e.type){const t=e.def.host||null;t&&t.refresh(!1,null,null),e.domNode=e.parent&&t&&t.getRootDomNode()||null,M.updateDomChainBy(e,e.domNode)}else{const t=e.domNode;if(t){const e=t.parentNode;n.push([s,e]),e&&e.removeChild(t)}M.updateDomChainBy(e,t)}if(s.swap){const t=e.domNode;let o=('portal'===e.type?e.def.domPortal:e.def.domElement)||null;if(t!==o){if('dom'===e.type){const n=e,s=t&&t.parentNode;if(o&&(o=this.getApprovedNode(o,n),o)){let[n,i]=s?[s,t]:M.findInsertionNodes(e);n&&n.insertBefore(o,i)}if(t){if(this.externalElements.delete(t),n.domProps&&t instanceof Element)for(const e in n.domProps){const o=M.LISTENER_PROPS[e];o&&t.removeEventListener(o,n.domProps[e])}s&&s.removeChild(t)}n.domProps&&(n.domProps=o&&'read'===this.settings.renderDomPropsOnSwap?M.readFromDom(o):{},i=!0)}for(const t of e.children){const e=t.domNode;e&&(e.parentNode&&e.parentNode.removeChild(e),o&&o.appendChild(e))}e.domNode=o,M.updateDomChainBy(e,o)}}if(s.content&&'dom'===e.type&&e.domNode){const t=e.def.domContent,o=e.domNode;let n=o;if('content'===e.def._uiDefType){if(e.def.domHtmlMode&&null!=t&&''!==t)n=M.domNodeFrom(t.toString(),e.def.tag||this.settings.renderHtmlDefTag,!0),e.domProps&&(i=!0,e.domProps={});else{const e=null==t?'':(this.settings.renderTextContent?this.settings.renderTextContent(t):t).toString();3!==o.nodeType?n=document.createTextNode(e):o.textContent=e}}else if(t instanceof Node){const e=t.parentNode;e&&e.removeChild(t)}else o.textContent='';if(o!==n){const t=o.parentNode;t&&(e.domNode=n,t.insertBefore(n,o),t.removeChild(o)),M.updateDomChainBy(e,e.domNode)}const s=e.def.attachedRefs;if(s)for(const o of s)o&&o.domDidContent&&o.domDidContent(e.domNode,null!=t?t:null)}if((r||i||s.update)&&'dom'===e.type&&e.domNode&&e.domNode instanceof Element){const t=M.domApplyProps(e,this.settings.devLogWarnings),{appliedProps:o}=t,n=A(t,['appliedProps']);if(e.domProps=o,s.update){const t=e.def.attachedRefs;if(t)for(const o of t)o&&o.domDidUpdate&&o.domDidUpdate(e.domNode,n)}}s.emptyMove&&M.updateDomChainBy(e,null,!0)}let s=n.length-1;if(s>=0){let e,t=!1;for(;e=n[s--];){const[{move:o,treeNode:n}]=e,s=n.domNode,[i,r]=s?M.findInsertionNodes(n):[null,null];if(i&&s){const d=s.nextSibling,a=i!==s.parentNode||r!==d;a&&i&&i.insertBefore(s,r);const c=n.def&&n.def.attachedRefs;c&&(a||o&&this.settings.callRefMoveEvenIfNoDomMove)&&(t=!0,e[2]=d,e[3]=c)}else!this.settings.devLogWarnings||s||i||console.warn('__UIRender.applyToDom: Error: Cannot move element: ',s,' into parent: ',i,' for treeNode: ',n)}if(t)for(s=0;e=n[s];s++){if(!e[3])continue;const[t,o,n,s]=e,i=t.treeNode.domNode;for(const e of s)t.move?e.domDidMove&&e.domDidMove(i,o,n):(f.didAttachOn(e,t.treeNode),e&&e.domDidMount&&e.domDidMount(i))}}}static findInsertionNodes(e){let t=null,o=e.parent;for(;o;){if(!(M.PASSING_TYPES[o.type]||'root'===o.type&&o.parent)){t=o.domNode;break}o=o.parent}if(!t)return[null,null];let n=null,s=e;for(;s&&(o=s.parent,o);){let e,i=o.children.indexOf(s)+1;for(;e=o.children[i];){if(e.domNode&&'portal'!==e.type){n=e.domNode;break}i++}if(n||o.domNode===t)break;s=o}return[t,n]}static updateDomChainBy(e,t,o=!1){let n=e,s=o?e:e.parent,i=t;for(;s&&M.PASSING_TYPES[s.type]&&(s.children[0]===n||s===n);){if(!i){let e,t=s.children.indexOf(n)+1;for(;e=s.children[t];){if(e.domNode&&'portal'!==e.type){i=e.domNode;break}t++}}s.domNode=i,n=s,s=s.parent}}static readFromDom(e){const t={};if(!(e instanceof Element))return t;for(const o of e.getAttributeNames())t[o]=e.getAttribute(o);return e.style.cssText&&(t.style=n.cleanHtmlStyle(e.style.cssText)),t}static domNodeFrom(e,t='div',o=!1){const n=t instanceof Element?t:document.createElement(t);return n.innerHTML=e,o||n.children[1]?n:n.children[0]}static domApplyProps(e,t=!1){const o=e.domNode,s=e.def.props||{},i=e.domProps||{},r={},d={appliedProps:r};if(!o)return d;const a=n.getDictionaryDiffs(i,s,['style','class']);if(a){d.attrDiffs=a;for(const n in a){const s=a[n],d=void 0!==s,c=M.LISTENER_PROPS[n];if(M.IGNORE_PROPS[n])t&&console.warn('__UIRender.domApplyProps: Warning: Is using an ignored dom prop: ',n,' for treeNode: ',e);else{if(c){const e=i[n];e&&o.removeEventListener(c,e),d&&o.addEventListener(c,s)}else d?o.setAttribute(n,s):o.removeAttribute(n);d?r[n]=s:delete r[n]}}}const c=i.style||s.style?n.getDictionaryDiffs(i.style||{},s.style||{}):null;if(c){d.styleDiffs=c,r.style||(r.style={});for(const e in c){const t=c[e];null==t?(o.style[e]='',delete r.style[e]):(o.style[e]=t,r.style[e]=t)}}const u=i.class!==(s.class||void 0)?n.getClassNameDiffs(i.class,s.class):null;if(u){d.classDiffs=u;for(const e in u)u[e]?o.classList.add(e):o.classList.remove(e);s.class?r.class=s.class:delete r.class}return d}}M.IGNORE_PROPS={innerHTML:!0,textContent:!0},M.PASSING_TYPES={boundary:!0,pass:!0,contexts:!0,host:!0},M.LISTENER_PROPS=['Abort','AnimationCancel','AnimationEnd','AnimationIteration','AnimationStart','AuxClick','Blur','CanPlay','CanPlayThrough','Change','Click','Close','ContextMenu','CueChange','DblClick','Drag','DragEnd','DragEnter','DragLeave','DragOver','DragStart','Drop','DurationChange','Emptied','Ended','Error','Focus','GotPointerCapture','Input','Invalid','KeyDown','KeyPress','KeyUp','Load','LoadedData','LoadedMetaData','LoadStart','LostPointerCapture','MouseDown','MouseEnter','MouseLeave','MouseMove','MouseOut','MouseOver','MouseUp','Pause','Play','Playing','PointerCancel','PointerDown','PointerEnter','PointerLeave','PointerMove','PointerOut','PointerOver','PointerUp','Progress','RateChange','Reset','Resize','Scroll','SecurityPolicyViolation','Seeked','Seeking','Select','Stalled','Submit','Suspend','TimeUpdate','Toggle','TouchCancel','TouchEnd','TouchMove','TouchStart','TransitionCancel','TransitionEnd','TransitionRun','TransitionStart','VolumeChange','Waiting','Wheel'].reduce(((e,t)=>(e['on'+t]=t.toLowerCase(),e)),{});const P={SEARCH_TAG_BY_TYPE:{fragment:1,portal:2,pass:3,contexts:4,host:5},runContentPassUpdate(e,t=!1){const[o,n,s]=P.assignTreeNodesForPass(e);let[i,r]=P.applyDefPairs(e,o,t);if(n[0]){const t=new Set;for(const e of n)e.sourceBoundary||(e.def&&t.add(e.def),e.parent=null);if(t.size){i=P.cleanUpBoundaryDefs(t,e.uiHost.settings.devLogCleanUp).concat(i)}}return s[0]&&(i=s.map((e=>({treeNode:e,emptyMove:!0}))).concat(i)),e.isMounted=!0,[i,r]},runBoundaryUpdate(e,t=!1){let o=null,n=e._innerDef;e.uiId?(o=i.createDefFromContent(e.render()),o&&!n&&(n=i.newAppliedDefBy(o,e.closure))):o=e.targetDef;const[s,r]=n?P.buildDefMaps(n):[new Map,new Set];let d,a;const c=[];if(o){const i=[],u=P.pairDefs(e,o,n,s,r,i,c);e._innerDef=u[0][1];const l=P.applyDefPairs(e,u,t);if(d=l[0],a=l[1],i[0])for(const e of i){const t=e.treeNode;t&&null===t.sourceBoundary&&r.add(e)}}else d=[{treeNode:e.treeNode,emptyMove:!0}],a=[],e.innerBoundaries=[],e.treeNode.children=[],e._innerDef=null;if(r.size){d=P.cleanUpBoundaryDefs(r,e.uiHost.settings.devLogCleanUp).concat(d)}return c[0]&&(d=c.map((e=>({treeNode:e,emptyMove:!0}))).concat(d)),e.isMounted||(e.isMounted=!0),delete e._outerContextsWere,[d,a]},applyDefPairs(o,s,i=!1){const d=o.uiId?o:o.sourceBoundary,a=[],c=o.uiHost.settings.preEqualCheckDomProps;o.innerBoundaries=[];let u=[],l=[];for(const h of s){const[s,p,m,y]=h,g='mounted'===p.action;if(!g&&'moved'===p.action)switch(p._uiDefType){case'contexts':case'fragment':for(const e of r.rootDomTreeNodes(m,!0,!0))-1===a.indexOf(e)&&(a.push(e),u.push({treeNode:e,move:!0}));break;case'host':p.host&&p.host.groundedTree.parent===m&&u.push({treeNode:m,move:!0})}if('fragment'===p._uiDefType)continue;if('pass'===m.type){if('pass'!==p._uiDefType)continue;if(p.contentPass){const[e,t]=p.contentPass.contentGrounded(p,o,m,p.key!==te.key?p.key:null);u=u.concat(e),l=l.concat(t)}m.boundary&&o.innerBoundaries.push(m.boundary);continue}const D=p.props;let v=!1;switch(s.props&&p.props!==s.props&&(m.boundary&&P.preSetUpdates(m.boundary,{props:s.props}),p.props=s.props||{}),p._uiDefType){case'content':const e=s.domHtmlMode;v=p.domContent!==s.domContent||e!==s.domHtmlMode,v&&(p.domContent=s.domContent,void 0!==e?p.domHtmlMode=e:delete p.domHtmlMode);break;case'element':p.domElement!==s.domElement&&(g||u.push({treeNode:m,swap:!0}),p.domElement=s.domElement||null),p.domCloneMode=null!=s.domCloneMode?s.domCloneMode:null;break;case'portal':p.domPortal!==s.domPortal&&(g||u.push({treeNode:m,swap:!0}),p.domPortal=s.domPortal||null);break;case'contexts':{const e=p.contexts,t=s.contexts||null;if(e!==t){if(e)for(const o in e){const n=e[o];if(n&&n!==(t&&t[o]||null)){n.onRemoveFrom&&n.onRemoveFrom(m,o);const e=n.inTree.get(m);e&&e.size>1?e.delete(o):n.inTree.delete(m)}}for(const o in t){const n=t[o];if(n&&n!==(e&&e[o]||null)){n.onInsertInto&&n.onInsertInto(m,o);const e=n.inTree.get(m);e?e.add(o):n.inTree.set(m,new Set([o]))}}p.contexts=t}break}}switch(s._uiDefType){case'dom':case'content':case'element':if(g)u.push({treeNode:m,create:!0});else{const e='moved'===p.action&&-1===a.indexOf(m),t=!!p.tag&&(!c||'if-needed'===c&&(v||e)||!n.equalDomProps(D||{},s.props||{}));if(t||v||e){const o={treeNode:m};t&&(o.update=!0),v&&(o.content=!0),e&&(o.move=!0,a.push(m)),u.push(o)}}break;case'boundary':if(g){const e=new S(o.uiHost,p,m,d);e.parentBoundary=o,e.outerContexts=Object.assign({},y),m.boundary=e}break;case'portal':g&&u.push({treeNode:p.treeNode,create:!0});break;case'host':p.host&&null===p.host.groundedTree.parent&&(p.host.groundedTree.parent=m,m.children=[p.host.groundedTree],u.push({treeNode:m,move:!0}),p.host.settings.welcomeContextsUpRoot&&p.host.services.onContextPass(y))}if((p.attachedContexts||s.attachedContexts)&&P.handleAttachedContexts(p,s),m.boundary){const n=m.boundary;o.innerBoundaries.push(n),g&&n.reattach(!1);let r=null;if(s.childDefs[0]){const e=n.closure.envelope;r=e?{appliedDef:Object.assign(Object.assign({},e.appliedDef),{childDefs:p.childDefs,action:p.action}),targetDef:Object.assign(Object.assign({},e.targetDef),{childDefs:s.childDefs})}:{appliedDef:{tag:null,_uiDefType:'fragment',childDefs:p.childDefs,action:'mounted'},targetDef:{tag:null,_uiDefType:'fragment',childDefs:s.childDefs}}}let d=n.closure.preRefresh(r);if(!g){let o=0;const s=n.contextApi;for(const i in n.outerContexts){const r=n.outerContexts[i];y[i]===r||s&&void 0!==s.getContext(i,t.Parent|t.Overridden)||(o|=e.Otherwise,s&&(o|=P.helpUpdateContext(n,i,y[i]||null,r)))}for(const i in y){if(void 0!==n.outerContexts[i])continue;const r=y[i];n.outerContexts[i]===r||s&&void 0!==s.getContext(i,t.Parent|t.Overridden)||(o|=e.Otherwise,s&&(o|=P.helpUpdateContext(n,i,r,null)))}o&&(n._outerContextsWere=n.outerContexts,n.outerContexts=Object.assign({},y),s&&P.shouldUpdateContextually(o)&&(n._preUpdates||(n._preUpdates={}),n._preUpdates.contextual=!0))}const c=o.uiHost.services.updateBoundary(n,i,a,d,!0);c&&(u=u.concat(c[0]),l=l.concat(c[1]));const h=n.closure.applyRefresh(i);u=u.concat(h[0]),l=l.concat(h[1])}if(p.attachedRefs||s.attachedRefs){const e=p.attachedRefs,t=s.attachedRefs;if(e)for(const o of e)t&&t.includes(o)||f.willDetachFrom(o,m);if(t)for(const o of t)e&&e.includes(o)||f.didAttachOn(o,m);p.attachedRefs=t}}return[u,l]},pairDefs(e,t,o,n,s,i,r){const d=e.uiHost.settings,a=[],c=e.uiId?e:e.sourceBoundary;let u,l=[[{childDefs:[t]},{childDefs:[o]},e.treeNode,Object.assign({},e.outerContexts),!1]],h=0;for(;u=l[h];){h++;const[e,t,o,f,p]=u;let m=t.scopeMap||u[5];if(m&&'spread-pass'===t.scopeType&&(m=void 0),e.childDefs[0]){const a=P.findAppliedChildDefs(t,e,m||n,s,c,d);t.childDefs=a;const u=o&&'boundary'!==e._uiDefType&&('element'!==e._uiDefType||e.domElement)?P.assignTreeNodesForChildren(a,o,p,c,r):[],y=[];for(let t,o=0;t=e.childDefs[o];o++){const e=u[o],n=a[o];!e&&n.treeNode&&(n.treeNode.sourceBoundary=null,i&&i.push(n));const s=t.contexts?P.mergeOuterContexts(f,t.contexts):f,r=[t,n,u[o],s,'fragment'===t._uiDefType];m&&(r[5]=m),y.push(r)}l=y.concat(l.slice(h)),h=0}else t.childDefs=[];o&&e._uiDefType&&t._uiDefType&&a.push([e,t,o,f])}return a},findAppliedChildDefs(e,t,o,n,s,r){let d=t.childDefs.length;if(!d)return[];const a=!!r&&r.wideKeysInArrays,c=a||!t.isArray;if(!a&&t.isArray!=(e&&e.isArray))return t.childDefs.map((e=>i.newAppliedDefBy(e,s&&s.closure||null)));const u=!r||r.reuseSiblingTags,l=!!r&&r.noRenderValuesMode,h=e&&e.childDefs.slice()||null,f=[];for(let r=0;r<d;r++){const a=t.childDefs[r];let p=!1;if(l&&'content'===a._uiDefType?p=!0===l?!a.domContent:-1!==l.indexOf(a.domContent):'fragment'===a._uiDefType&&a.withContent&&(p=!s||!s.closure.envelope),p){t.childDefs.splice(r,1),d--,r--;continue}const m=null!=a.key,y=P.SEARCH_TAG_BY_TYPE[a._uiDefType]||a.tag;let g=null;if(h&&(m||u)){let e=-1;for(const t of h){e++;if((P.SEARCH_TAG_BY_TYPE[t._uiDefType]||t.tag)===y&&(m?t.key===a.key:null==t.key)&&n.has(t)&&(m||!0===u||!t.tag||'string'==typeof t.tag||!('dom'===u||'dom-mini'===u&&(t.tag.UI_DOM_TYPE?'Mini'!==t.tag.UI_DOM_TYPE:t.tag.length>=2)))){g=t,h.splice(e,1),n.delete(t);break}}}if(!g&&m&&c){const e=o&&o.get(y);if(e){let t=-1;for(const o of e)if(t++,o.key===a.key&&n.has(o)){g=o,n.delete(o),e.splice(t,1);break}}}g?g.action=e&&e.childDefs[r]===g?'updated':'moved':g=i.newAppliedDefBy(a,s&&s.closure||null),f.push(g)}return f},assignTreeNodesForChildren(e,t,o,n,s){t.children[0]&&(t.children=[]);const i=e.length;if(!i)return[];const r=[];let d=0,a=null,c=t;if(o){if(!t.parent)return[];if(c=t.parent,a=t,d=c.children.indexOf(t),-1===d)return[]}for(let t=0;t<i;t++){const o=e[t];let i=null;o.treeNode?i=o.treeNode:'fragment'!==o._uiDefType&&(o.action='mounted'),a&&(i?c.children.splice(d,1):i=a,a=null);const u=o._uiDefType,l='content'===u||'element'===u?'dom':'fragment'===u?'':u;if(i){if(i.parent){const e=i.parent.children.indexOf(i);0===e&&i.parent!==c&&!0===M.PASSING_TYPES[i.parent.type]&&s&&-1===s.indexOf(i.parent)&&s.push(i.parent),-1!==e&&i.parent.children.splice(e,1)}i.parent=c,i.sourceBoundary=n||null,i.type=l}else i={type:l,parent:c,children:[],sourceBoundary:n||null,domNode:null},'dom'===i.type&&(i.domProps={});'fragment'!==o._uiDefType&&(i.def=o,o.treeNode=i),c.children.splice(d+t,0,i),r.push(i)}return r},assignTreeNodesForPass(e){const t=e._innerDef,o=e.sourceBoundary,n=[],s=[],i=[];let r,d=[[e.targetDef,t,e.treeNode,Object.assign({},e.outerContexts),!1]],a=0;for(;r=d[a];){a++;const[e,t,c,u,l]=r;if(e.childDefs[0]){const i=c&&'boundary'!==e._uiDefType&&('element'!==e._uiDefType||e.domElement)?P.assignTreeNodesForChildren(t.childDefs,c,l,o,s):[];let r=0;const h=[];for(const o of t.childDefs){const t=i[r];!t&&o.treeNode&&(n.push(o.treeNode),o.treeNode.sourceBoundary=null);const s=e.childDefs[r],d=s.contexts?P.mergeOuterContexts(u,s.contexts):u;h.push([s,o,t,d,'fragment'===o._uiDefType]),r++}d=h.concat(d.slice(a)),a=0}c&&i.push([e,t,c,u])}return[i,n,s]},buildDefMaps(e,t=!1,o=new Set,n){const s=new Map;let i,r=t?e.childDefs.slice():[e],d=0;for(;i=r[d];){d++,o.add(i);const e=P.SEARCH_TAG_BY_TYPE[i._uiDefType]||i.tag,t=s.get(e);if(t?t.push(i):s.set(e,[i]),i.scopeType)if('spread-pass'===i.scopeType)n&&n.push(i);else{const e=[];i.scopeMap=P.buildDefMaps(i,!0,o,e)[0],e[0]&&(r=e[0].childDefs.concat(r.slice(d)),d=0)}else i.childDefs[0]&&(r=i.childDefs.concat(r.slice(d)),d=0)}return[s,o]},cleanUpBoundaryDefs(e,t=!1){t&&console.log('___Apply.cleanUpBoundaryDefs: Dev-log: Clean up unused defs: ',[...e]);let o=[];for(const t of e){const e=t.treeNode;if(e){switch(t._uiDefType){case'dom':case'element':case'content':o.push({treeNode:e,remove:!0});break;case'boundary':e.boundary&&(o=o.concat(P.destroyBoundary(e.boundary,!1)[0]));break;case'pass':t.contentPass&&(o=o.concat(t.contentPass.contentUngrounded(t)[0]));case'host':t.host&&t.host.groundedTree.parent===e&&(t.host.groundedTree.parent=null,e.children=[],o.push({treeNode:e,move:!0}));case'contexts':if(t.contexts)for(const o in t.contexts){const n=t.contexts[o];if(!n)continue;n.onRemoveFrom&&n.onRemoveFrom(e,o);const s=n.inTree.get(e);s&&s.size>1?s.delete(o):n.inTree.delete(e)}default:if(t.attachedRefs&&t._uiDefType)for(const o of t.attachedRefs)f.willDetachFrom(o,e)}e.parent=null,e.sourceBoundary=null,delete t.treeNode}}return o},destroyBoundary(e,t=!0,o=!0){let n=[];const s=r.boundariesWithin(e,!0);for(const e of s){if(null===e.isMounted)continue;const s=e.uiId?e:null;if(s){const e=s.live;if(e){e.uiWillUnmount&&e.uiWillUnmount(),e.clearTimers();const t=s,o=t.contextApi.getContexts();for(const e in o){const n=o[e];n&&P.helpUpdateContext(t,e,null,n)}}if(s.mini){const e=s.mini,t=e.constructor;e.uiWillUnmount&&e.uiWillUnmount(),'Wired'===t.UI_DOM_TYPE&&(t.uiWillUnmount&&t.uiWillUnmount(s),t.uiBoundaries.delete(s))}}const i=o?r.rootDomTreeNodes(e.treeNode,!1):[];if(e._innerDef&&e._innerDef.childDefs[0]){let n,r=[e._innerDef],d=0;for(;n=r[d];){d++,n.childDefs[0]&&(r=n.childDefs.concat(r.slice(d)),d=0);const e=n.treeNode;if(e){const r='dom'===e.type;if(n.attachedRefs)for(const t of n.attachedRefs)r?o&&-1===i.indexOf(e)&&i.push(e):t.uiWillUnmount&&e.boundary&&'boundary'===e.type&&t.uiWillUnmount(e.boundary),f.willDetachFrom(t,e);r&&!s&&t&&(e.sourceBoundary=null,e.parent=null,delete n.treeNode)}}}if(e._outerDef.attachedRefs)for(const t of e._outerDef.attachedRefs)s&&t.uiWillUnmount&&t.uiWillUnmount(s),f.willDetachFrom(t,e.treeNode);s&&s.uiHost.services.cancelUpdates(s),o&&(n=n.concat(i.map((e=>({treeNode:e,remove:!0}))))),e.isMounted=null}return[n,[]]},handleAttachedContexts(t,o){if(!t.treeNode||!t.attachedContexts&&!o.attachedContexts)return;const n=t.treeNode,s='boundary'===n.type&&n.boundary||null,i=t.attachedContexts||{};t.attachedContexts=o.attachedContexts;const r=s&&s.contextApi;if(r&&(r.actionNeeds||r.contextNeeds.size)){const t=r.overriddenContexts||{},n=o.attachedContexts||{},d=new Set([...Object.keys(i),...Object.keys(n)]);let a=0;for(const o of d){if(void 0!==t[o])continue;const r=void 0===i[o]?s.outerContexts[o]:i[o],d=n[o];d!==r&&(a|=e.Otherwise,a|=P.helpUpdateContext(s,o,d,r))}P.shouldUpdateContextually(a)&&(s._preUpdates||(s._preUpdates={}),s._preUpdates.contextual=!0)}},helpUpdateContext(t,o,n,s){let i=0;if(t.contextApi.contextNeeds.has(o)&&(s&&s.services.onDisInterest('data',t,o),n&&n.services.onInterest('data',t,o),i|=e.Data),t.contextApi.actionNeeds.has(o)&&(s&&s.services.onDisInterest('actions',t,o),n&&n.services.onInterest('actions',t,o),i|=e.Actions),t.live.onContextChange){const r=t.live.onContextChange(o,n,s);null!==r&&(i|=r?e.DoRefresh:e.NoRefresh)}return i},mergeOuterContexts(e,t){const o=Object.assign({},e);for(const e in t){const n=t[e];n?o[e]=n:delete o[e]}return o},afterOuterContexts(t){const o=[];if(!t._outerContextsWere)return o;const n={},s=t.outerContexts;for(const e in t.outerContexts){const o=t._outerContextsWere[e];t.outerContexts[e]!==o&&(n[e]=o)}for(const e in t._outerContextsWere)void 0===t.outerContexts[e]&&(n[e]=t._outerContextsWere[e]);t.outerContexts=t._outerContextsWere,delete t._outerContextsWere;let i,r=[[t.treeNode,n]],d=0;for(;i=r[d];){d++;const t=i[0],n=i[1];if('host'===t.type){const e=t.def.host;if(e&&e.settings.welcomeContextsUpRoot){const t=e.rootBoundary,o=Object.assign({},t.outerContexts);let i=!1;for(const e in n)if(t.outerContexts[e]===n[e]){i=!0;const t=s[e];t?o[e]=t:delete o[e]}i&&e.services.onContextPass(o)}}else if(t.boundary){const i=t.boundary,a={};let c=0;for(const t in n)if(i.outerContexts[t]===n[t]){const n=s[t],r=a[t];if(n?i.outerContexts[t]=n:delete i.outerContexts[t],a[t]=r,c|=e.Otherwise,i.contextApi){if(n!==i.contextApi.getContext(t))continue;c|=P.helpUpdateContext(i,t,n,r),void 0!==i.contextApi.contextNeeds.get(t)&&-1===o.indexOf(i)&&o.push(i)}}if(delete i._outerContextsWere,!c)continue;i.uiId&&P.shouldUpdateContextually(c)&&(i._preUpdates||(i._preUpdates={}),i._preUpdates.contextual=!0),t.children[0]&&(r=t.children.map((e=>[e,a])).concat(r.slice(d)),d=0)}else if(t.children[0]){const e='contexts'===t.type?t.def.contexts:null;let o=n;if(e){const t=[];for(const o in n)void 0!==e[o]&&t.push(o);if(t[0]){o=Object.assign({},n);for(const e of t)delete o[e];void 0===Object.keys(o)[0]&&(o=null)}}o&&(r=t.children.map((e=>[e,o])).concat(r.slice(d)),d=0)}}return o},shouldUpdateContextually:t=>0==(t&e.NoRefresh)&&0!=(t&(e.DoRefresh|e.Data)),shouldUpdateBy(e,t,o){const s=e.uiHost.settings,i=e.live?e.live.updateModes:{props:e.mini&&(e.mini.updateMode||e.mini.constructor.updateMode)||s.updateMiniMode};let r=!1;if(t)for(const e in t){r=!0;switch(i[e]||s.updateLiveModes[e]){case'always':return!0;case'changed':if(t[e]!==o[e])return!0;break;case'shallow':if(!n.areEqual(t[e]||{},o[e],1))return!0;break;case'double':if(!n.areEqual(t[e]||{},o[e],2))return!0;break;case'deep':if(!n.areEqual(t[e]||{},o[e],-1))return!0}}return!r&&(e.mini?'always'===s.updateMiniMode:s.shouldUpdateWithNothing)},sortBoundaries(e){const t=new Map;for(const o of e){let e=o.uiId,n=o.parentBoundary;for(;n;)e=(n.uiId||'')+'>'+e,n=n.parentBoundary;const s=t.get(e);if(s){let e=0;if(o.parentBoundary){const t=o.parentBoundary.innerBoundaries,n=t.indexOf(o);for(const o of s){if(n<t.indexOf(o))break;e++}}s.splice(e,0,o)}else t.set(e,[o])}const o=[];for(const e of t.keys()){let t=0,n=!1;for(const s of o){if(s.startsWith(e+'>'))break;if(e.startsWith(s+'>'))n=!0;else if(n)break;t++}o.splice(t,0,e)}let n=0;for(const s of o)for(const o of t.get(s))e[n]=o,n++},preSetUpdates(e,t){const o=e.live;let n=e._preUpdates;n||(e._preUpdates=n={}),t.props&&(n.props||(n.props=e._outerDef.props||{}),e._outerDef.props=t.props,o?o.props=t.props:e.mini&&(e.mini.props=t.props)),t.state&&o&&(n.state||(n.state=o.state),o.state=t.state),t.children&&e.closure&&(n.children||(n.children=e.closure.envelope?e.closure.envelope.targetDef.childDefs.slice():[])),t.contextual&&o&&(n.contextual||(n.contextual=!0)),t.force&&(n.force='all'!==t.force&&'all'!==n.force||'all')}};class w{constructor(e){this.uiBoundary=e,this.actionNeeds=new Map,this.contextNeeds=new Map}needsAction(e,t,o=!0){const n=this.actionNeeds.get(e);if(!0===n)return;const s=this.getContext(e);o?(n?n.add(t):this.actionNeeds.set(e,new Set([t])),s&&s.services.onInterest('actions',this.uiBoundary,e)):n&&n.has(t)&&(n.delete(t),n.size||(this.actionNeeds.delete(e),s&&s.services.onDisInterest('actions',this.uiBoundary,e)))}needsActions(e,t=[],o=!0){const n=this.actionNeeds.get(e);if('boolean'==typeof t)t?this.actionNeeds.set(e,!0):this.actionNeeds.delete(e);else if(o&&this.actionNeeds.size){if(t.length)if(n){if(!0!==n)for(const e of t)n.add(e)}else this.actionNeeds.set(e,new Set(t))}else t.length?this.actionNeeds.set(e,new Set(t)):this.actionNeeds.delete(e);if(!t!=!n){const o=this.getContext(e);o&&(t?o.services.onInterest('actions',this.uiBoundary,e):o.services.onDisInterest('actions',this.uiBoundary,e))}}needsActionsBy(e,t,o=!0){if(!o){const t=this.uiBoundary.contextApi.actionNeeds;for(const o of t.keys())void 0===e[o]&&t.delete(o)}for(const o in e)this.uiBoundary.contextApi.needsActions(o,e[o],t)}needsData(e,t=!0,o=!0){const n=!!this.contextNeeds.get(e);if(!1===t?this.contextNeeds.delete(e):this.contextNeeds.set(e,'string'==typeof t?[t]:t),n!==!t)return!1;const s=this.getContext(e)||null;return s&&(t?s.services.onInterest('data',this.uiBoundary,e):s.services.onDisInterest('data',this.uiBoundary,e)),o&&this.updateRemote(),!0}needsDataBy(e,t=!0,o=!0){if(!t&&this.contextNeeds.size){e=Object.assign({},e);for(const t of this.contextNeeds.keys())void 0===e[t]&&(e[t]=!1)}let n=!1;for(const t in e)this.needsData(t,e[t],!1)&&(n=!0);return n&&o&&this.updateRemote(),n}overrideContext(e,o,n=!0){const s=this.getContext(e),i=void 0!==o?o:this.getContext(e,t.Parent|t.Cascading);let r=this.overriddenContexts;void 0===o?r&&(delete r[e],Object.keys(r).length||delete this.overriddenContexts):(r||(r=this.overriddenContexts={}),r[e]=o);const d=s!==i?P.helpUpdateContext(this.uiBoundary,e,i||null,s||null):0;return n&&P.shouldUpdateContextually(d)&&this.updateRemote(),d}overrideContexts(e,t=!0){let o=0;for(const t in e)o|=this.overrideContext(t,e[t],!1);return t&&P.shouldUpdateContextually(o)&&this.updateRemote(),o}getContext(e,o=t.All){if(o&t.Overridden){const t=this.overriddenContexts;if(t&&void 0!==t[e])return t[e]}if(o&t.Parent){const t=this.uiBoundary._outerDef.attachedContexts;if(t&&void 0!==t[e])return t[e]}if(o&t.Cascading)return this.uiBoundary.outerContexts[e]}getContexts(e,o=t.All){const s=e?n.buildRecordable(e):null,i={};if(o&t.Cascading)for(const e in this.uiBoundary.outerContexts)s&&!s[e]||(i[e]=this.uiBoundary.outerContexts[e]);if(o&t.Parent){const e=this.uiBoundary._outerDef.attachedContexts;if(e)for(const t in e)s&&!s[t]||(i[t]=e[t])}if(o&t.Overridden){const e=this.overriddenContexts;if(e)for(const t in e)s&&!s[t]||(i[t]=e[t])}return i}updateRemote(e,t){this.uiBoundary.isMounted?this.uiBoundary.uiHost.services.absorbUpdates(this.uiBoundary,{contextual:!0},e,t):this.contextNeeds.size&&this.rebuildRemote()}rebuildRemote(){const e={},t={},o=this.uiBoundary.contextApi.overriddenContexts,n=this.uiBoundary._outerDef.attachedContexts;for(const s of this.contextNeeds.keys()){let i=o?o[s]:void 0;n&&void 0===i&&(i=n[s]),void 0===i&&(i=this.uiBoundary.outerContexts[s]),t[s]=i||null,e[s]=i?i.data:null}const s=this.uiBoundary.live;s.buildRemote&&(s.remote=s.buildRemote(e,t))}}class U{constructor(e){e&&(this.readChildren=e)}readChildren(e){return null}getChildren(e=!1,t=!0){return e||'boolean'==typeof this.childrenNeeds||(this.childrenNeeds='temp'),this.readChildren(t)}needsChildren(e){null==e?delete this.childrenNeeds:this.childrenNeeds=e}}class O{constructor(e,t){this.thruBoundary=e,this.sourceBoundary=t||null,this.envelope=null,this.truePassDef=null,this.groundedDefsMap=new Map,this.pendingDefs=new Set}contentGrounded(e,t,o,n){return this.groundedDefsMap.get(e)?'moved'===e.action&&o.boundary?[r.rootDomTreeNodes(o.boundary.treeNode,!0).map((e=>({treeNode:e,move:!0}))),[]]:[[],[]]:(this.groundedDefsMap.set(e,[t,o,n]),this.applyContentDefs([e]))}contentUngrounded(e){const t=this.groundedDefsMap.get(e);if(!t)return[[],[]];this.truePassDef===e&&(this.truePassDef=null),this.groundedDefsMap.delete(e),this.pendingDefs.delete(e);const o=t[1].boundary;return o?P.destroyBoundary(o):[[],[]]}preRefresh(e){if(!this.envelope&&!e)return[];const t=this.envelope?this.envelope.targetDef.childDefs.slice():[];this.envelope=e,this.pendingDefs=new Set(this.groundedDefsMap.keys());const o=[];for(const[e]of this.groundedDefsMap.values()){let n=e;for(;n;){const e=n.contentApi;if(e&&(e.childrenNeeds&&(o.push(n),n._preUpdates?n._preUpdates.children||(n._preUpdates.children=t):n._preUpdates={children:t}),!n.closure.envelope))break;if(n=n.sourceBoundary,n===this.sourceBoundary)break}}return o[0]&&o.reverse(),o}applyRefresh(e=!1){let t=[],o=[];if(this.pendingDefs.size&&([t,o]=this.applyContentDefs(this.pendingDefs,e)),!this.truePassDef&&this.envelope){const e=this.thruBoundary.uiHost.settings.devLogCleanUp;for(const n of this.envelope.appliedDef.childDefs){const s=n.treeNode;if(s){if(e&&console.log('__UIContentClosure.applyRefresh dev-log - clean up treeNode (no true pass): ',s),'dom'===s.type)t.push({treeNode:s,remove:!0});else if(s.boundary){const[e,n]=P.destroyBoundary(s.boundary);t=t.concat(e),o=o.concat(n)}s.parent=null,s.sourceBoundary=null,delete n.treeNode}}}return[t,o]}applyContentDefs(e,t=!1){e||(e=this.groundedDefsMap.keys());let o=[],n=[];for(const s of e){this.pendingDefs.delete(s);const e=this.groundedDefsMap.get(s);if(void 0===e)continue;let[i,r,d]=e,a=r.boundary;if(this.envelope&&this.sourceBoundary){let e=!0;a?(e=this.truePassDef===s,a.updateEnvelope(this.envelope.targetDef,e?this.envelope.appliedDef:null)):(a=new E(s,this.envelope.targetDef,r,this.sourceBoundary),e=null==d&&(!this.truePassDef||this.truePassDef===s),e&&(a._innerDef.childDefs=this.envelope.appliedDef.childDefs,this.truePassDef=s),a.parentBoundary=i,r.boundary=a);const[c,u]=e?P.runContentPassUpdate(a,t):P.runBoundaryUpdate(a,t);o=o.concat(c),n=n.concat(u)}else a&&(o=o.concat(P.destroyBoundary(a,!1)[0]),r.boundary=null)}return[o,n]}}class R{constructor(e,t,o){this.uiHost=e,this.treeNode=o,this._outerDef=t,this._innerDef=null,this.isMounted=!1,this.sourceBoundary=null,this.parentBoundary=null,this.innerBoundaries=[],this.outerContexts={}}}class E extends R{constructor(e,t,o,n){super(n.uiHost,e,o),this.sourceBoundary=n,this.targetDef=t,this._innerDef=i.newAppliedDefBy(t,n.closure)}updateEnvelope(e,t){this.targetDef=e,t&&(this._innerDef.childDefs=t.childDefs)}}class S extends R{constructor(e,t,o,n){super(e,t,o),this._notRendered=!0,this.uiId=e.services.createBoundaryId(),this.sourceBoundary=n||null,this.closure=new O(this,n)}reattach(e=!0){e&&(delete this.contextApi,delete this.contentApi,delete this.live,delete this.mini),this.type='';let t=this._outerDef.tag;if('function'==typeof t){let e=null,o=null,n=null;switch(t.UI_DOM_TYPE){case void 0:t.length<2?(this.type='mini',e=g,n=this._outerDef.tag):(this.type='live',o=T,n=this._outerDef.tag);break;case'Live':this.type='class-live',o=t;break;case'Mini':this.type='class-mini',e=t,n=this._outerDef.tag;break;case'Wired':this.type='class-wired',e=t}const s=o||e?(e=!0)=>{var t;const o=(null===(t=this.closure.envelope)||void 0===t?void 0:t.targetDef.childDefs)||null;return o&&(e?o.slice():o)}:null;if(o&&(this.contentApi=new U(s),this.contextApi=new w(this),this.live=new o(this._outerDef.props||{},this),n&&(this.live.render=n),this.live.uiBoundary||(this.live.uiBoundary=this)),e&&(this.contentApi=new U(s),this.mini=new e(this._outerDef.props||{}),n&&(this.mini.render=n),this.mini.isMounted=()=>!0===this.isMounted,this.mini.getChildren=this.contentApi.getChildren.bind(this.contentApi),this.mini.needsChildren=this.contentApi.needsChildren.bind(this.contentApi),'class-wired'===this.type)){const t=e;t.uiBoundaries.add(this),t.uiWillMount&&t.uiWillMount(this)}}}update(e,t,o){this.uiHost.services.absorbUpdates(this,{force:this.isMounted?e||!1:'all'},t,o)}updateBy(e,t,o,n){this.uiHost.services.absorbUpdates(this,Object.assign(Object.assign({},e),{force:this.isMounted?t||!1:'all'}),o,n)}render(e=0){let t;e||(this._renderState='active'),this.contentApi&&'temp'===this.contentApi.childrenNeeds&&delete this.contentApi.childrenNeeds;const o=this._outerDef.props||{};if(this.mini?t=this.mini.render(o):this.live&&(t='live'===this.type?this.live.render(o,this.live):this.live.render()),'function'==typeof t)return this.mini?this.mini.render=t:this.live&&(this.live.render=t),this.render(e);if(this._notRendered){delete this._notRendered;const e=this.live;if(e&&e.onContextChange&&'live'===this.type){const t=e.getContexts();for(const o in t)e.onContextChange(o,t[o],null)}}if('re-updated'===this._renderState){const t=this.uiHost.settings.maxReRenders;if(t<0||e<t)return e++,this._renderState='active',this.render(e);this.uiHost.settings.devLogWarnings&&console.warn('__UISourceBoundary.render: Warning: The boundary tried to render for over '+(e+1).toString()+' times.','class-live'===this.type&&this.live&&this.live.constructor||('class-wired'===this.type||'class-mini'===this.type)&&this.mini&&this.mini.constructor||this._outerDef.tag,this)}return delete this._renderState,t}}class I{constructor(e){this.uiHost=e,this.uiRender=new M(e.settings),this.idCounter=0,this.updateTimer=null,this.renderTimer=null,this.updatesPending=new Set,this.postRenderInfos=[],this.postBoundaryCalls=[],this.listeners={update:[],render:[]}}createBoundaryId(){const e=this.idCounter;return this.idCounter++,'q-'+e.toString()}clearTimers(e=!1){e||this.runUpdates(null),null!==this.updateTimer&&(window.clearTimeout(this.updateTimer),this.updateTimer=null),null!==this.renderTimer&&(window.clearTimeout(this.renderTimer),this.renderTimer=null)}addListener(e,t){const o=this.listeners[e],n=o.indexOf(t);-1!==n?o[n]=t:o.push(t)}removeListener(e,t){const o=this.listeners[e],n=o.indexOf(t);-1!==n&&o.splice(n,1)}createRoot(e){return this.rootDef=i.createDefFromContent(e),()=>this._rootIsDisabled?null:this.rootDef}updateRoot(e,t,o){this.rootDef=i.createDefFromContent(e),this.uiHost.rootBoundary.update(!0,t,o)}refreshRoot(e=!1,t,o){const n=!this._rootIsDisabled,s=this.uiHost,i=!(s.settings.onlyRunInContainer&&!s.groundedTree.domNode&&!s.groundedTree.parent);if(i?delete this._rootIsDisabled:this._rootIsDisabled=!0,!e&&i&&n){if(i&&n){const e=s.rootBoundary?r.rootDomTreeNodes(s.rootBoundary.treeNode,!0).map((e=>({treeNode:e,move:!0}))):[];this.absorbChanges(e,null,o)}}else s.rootBoundary.update(!0,t,o)}clearRoot(e=!1){this.clearTimers(e),this.rootDef=null}onContextPass(e){const t=this.uiHost.rootBoundary;t._outerContextsWere||(t._outerContextsWere=t.outerContexts),t.outerContexts=Object.assign({},e);const o=P.afterOuterContexts(t);for(const e of o)e._preUpdates&&this.absorbUpdates(e,{contextual:!0});this.runUpdates()}hasPending(e=!0,t=!0){return e&&null!==this.updateTimer||t&&null!==this.renderTimer||!1}cancelUpdates(e){this.updatesPending.delete(e)}absorbUpdates(e,t,o,n){null!==e.isMounted&&(void 0!==n&&(null===n||void 0===this._forcePostTimeout||null!==this._forcePostTimeout&&n<this._forcePostTimeout)&&(this._forcePostTimeout=n),P.preSetUpdates(e,t),e._renderState?e._renderState='re-updated':this.updatesPending.has(e)||(this.updatesPending.add(e),this._isUpdating||this.refreshWithTimeout('update',o)))}runUpdates(e){for(this.updateTimer=null,this._isUpdating=!0,e=void 0!==e?e:void 0!==this._forcePostTimeout?this._forcePostTimeout:this.uiHost.settings.renderTimeout,delete this._forcePostTimeout;this.updatesPending.size;){let e=[...this.updatesPending];this.updatesPending.clear(),e[1]&&P.sortBoundaries(e);let t=[],o=[];for(const n of e){const e=this.updateBoundary(n);e&&(t=t.concat(e[0]),o=o.concat(e[1]))}t[0]&&this.postRenderInfos.push(t),o[0]&&(this.uiHost.settings.uiDidImmediateCalls?I.callBoundaryChanges(o):this.postBoundaryCalls.push(o))}if(this.listeners.update[0])for(const e of this.listeners.update)e();this.refreshWithTimeout('render',e),delete this._isUpdating}updateBoundary(e,t=!1,o,n=[],s=!1){let i=!!t,d='all'===t,a=[],c=[];const u=e.contextApi;if(e.isMounted){let l=e._preUpdates;if(!l){if(!t)return null;l={}}const h={},f={};l.props&&(h.props=l.props,f.props=e._outerDef.props);const p=e.live;if(p&&u&&(l.state&&(h.state=l.state,f.state=p.state),l.contextual&&(h.remote=p.remote,u.rebuildRemote(),f.remote=p.remote)),l.force)i=!0,'all'===l.force&&(d=!0);else if(!i){let t=null;if(p)p.uiShouldUpdate&&(t=p.uiShouldUpdate(h,f));else if(e.mini)if(h.children&&h.children!==f.children)t=!0;else{const o=e.mini,n=o.constructor;o.uiShouldUpdate&&(t=o.uiShouldUpdate(h.props||null,f.props||null)),null==t&&n&&n.uiShouldUpdate&&(t=n.uiShouldUpdate(e,h.props||null,f.props||null))}(!0===t||null==t&&P.shouldUpdateBy(e,h,f))&&(i=!0)}const m='moved'===e._outerDef.action,y=m?i?'updated-n-moved':'moved':i?'updated':'';if(y&&c.push([e,y,h,f]),m){if(u){const t=u.getContexts();for(const o in t){const n=t[o];n&&n.services.onBoundaryMove(e,o)}}for(const t of r.rootDomTreeNodes(e.treeNode,!0,!0)){if(o){if(-1!==o.indexOf(t))continue;o.push(t)}a.push({treeNode:t,move:!0})}}delete e._preUpdates;const g=e.live&&e.live.uiWired||null;if(g)for(const e of g){const t=e.props;if(e.refresh(!1),t!==e.props)for(const t of e.uiBoundaries)t._preUpdates||(t._preUpdates={}),t._preUpdates.force||(t._preUpdates.force=!0),n.includes(t)||(n.push(t),s=!1)}if(p)p.uiBeforeUpdate&&p.uiBeforeUpdate(h,f,i);else if(e.mini){const t=e.mini,o=t.constructor;t.uiBeforeUpdate&&t.uiBeforeUpdate(h.props||null,f.props||null,i),o&&o.uiBeforeUpdate&&o.uiBeforeUpdate(e,h.props||null,f.props||null,i)}}else{if(null===e.isMounted)return null;c.push([e,'mounted']),i=!0}if(i){const[t,o]=P.runBoundaryUpdate(e,d);a=a.concat(t),c=c.concat(o)}else if(e._outerContextsWere){let t=P.afterOuterContexts(e);if(t[0]===e&&(t=t.slice(1)),t[0])if(n[0]){s=!1;for(const e of t)n.includes(e)||n.push(e)}else n=t}if(n[0]){const e=I.updateInterested(n,!s);a=a.concat(e[0]),c=c.concat(e[1])}return a[0]||c[0]?[a,c]:null}absorbChanges(e,t,o){e&&this.postRenderInfos.push(e),t&&(this.uiHost.settings.uiDidImmediateCalls?I.callBoundaryChanges(t):this.postBoundaryCalls.push(t)),this.refreshWithTimeout('render',o)}flushRender(){this.renderTimer=null;for(const e of this.postRenderInfos)e[0]&&this.uiRender.applyToDom(e);this.postRenderInfos=[];for(const e of this.postBoundaryCalls)e[0]&&I.callBoundaryChanges(e);if(this.postBoundaryCalls=[],this.listeners.render[0])for(const e of this.listeners.render)e()}refreshWithTimeout(e,t){'update'===e?this.updateTimer=n.refreshWithTimeout(this,this.runUpdates,this.updateTimer,this.uiHost.settings.updateTimeout,t):this.renderTimer=n.refreshWithTimeout(this,this.flushRender,this.renderTimer,this.uiHost.settings.renderTimeout,t)}static updateInterested(e,t=!0){let o=[],n=[];t&&P.sortBoundaries(e);for(const t of e){if(!t._preUpdates)continue;const e=t.uiHost.services.updateBoundary(t);e&&(o=o.concat(e[0]),n=n.concat(e[1]))}return[o,n]}static callBoundaryChanges(e){for(const t of e){const[e,o,n,s]=t,i=e.live||e.mini,r=e.mini&&e.mini.constructor;switch(o){case'updated':i&&i.uiDidUpdate&&(e.live?i.uiDidUpdate(n||{},s||{}):i.uiDidUpdate(n&&n.props||{},s&&s.props||{})),r&&r.uiDidUpdate&&r.uiDidUpdate(e,n&&n.props||{},s&&s.props||{});break;case'mounted':if(i&&i.uiDidMount&&i.uiDidMount(),r&&r.uiDidMount&&r.uiDidMount(e),e._outerDef.attachedRefs)for(const t of e._outerDef.attachedRefs)t.uiDidMount&&t.uiDidMount(e);break;case'updated-n-moved':case'moved':if(i&&i.uiDidMove&&i.uiDidMove(),r&&r.uiDidMove&&r.uiDidMove(e),'updated-n-moved'===o){i&&i.uiDidUpdate&&(e.live?i.uiDidUpdate(n||{},s||{}):i.uiDidUpdate(n&&n.props||{},s&&s.props||{})),r&&r.uiDidUpdate&&r.uiDidUpdate(e,n&&n.props||{},s&&s.props||{});break}}}}}function k(e){var t;return(t=class extends e{constructor(e,t,o){super(),this.settings=W.getDefaultSettings(o),this.services=new I(this),this.groundedTree={type:'root',parent:null,children:[],domNode:t||null,sourceBoundary:null};const n=this.services.createRoot(e),s=i.newAppliedDefBy({_uiDefType:'boundary',tag:n,props:{},childDefs:[]},null),r={type:'boundary',def:s,sourceBoundary:null,boundary:null,parent:this.groundedTree,children:[],domNode:null};this.groundedTree.children.push(r),this.rootBoundary=new S(this,s,r),this.rootBoundary.mini&&(this.rootBoundary.mini.updateMode='always'),r.boundary=this.rootBoundary,this.rootBoundary.reattach(!1),this.services.absorbUpdates(this.rootBoundary,{})}addListener(e,t){this.services.addListener(e,t)}removeListener(e,t){this.services.removeListener(e,t)}clear(e=!0,t,o){this.services.clearRoot(!0),e&&this.rootBoundary.update(!0,t,o)}update(e,t,o){this.services.updateRoot(e,t,o)}refresh(e=!1,t,o){this.services.refreshRoot(e,t,o)}refreshRender(e=!1,t){const o=!e||'read',n=[];let s,i=[...this.groundedTree.children],r=0;for(;s=i[r];)r+=1,s.domProps&&n.push({treeNode:s,refresh:o}),s.children[0]&&(i=s.children.concat(i.slice(r)),r=0);this.services.absorbChanges(n,null,t)}moveInto(e,t){if(this.groundedTree.domNode===e)return;this.groundedTree.domNode=e;const o=r.rootDomTreeNodes(this.rootBoundary.treeNode,!0).map((e=>({treeNode:e,move:!0})));(o[0]||void 0!==t)&&this.services.absorbChanges(o,null,t)}modifySettings(e){const t=this.settings.onlyRunInContainer,o=this.settings.welcomeContextsUpRoot;if(W.modifySettings(this.settings,e),void 0!==o&&o!==e.welcomeContextsUpRoot){const e=this.groundedTree.parent&&this.groundedTree.parent.sourceBoundary&&this.groundedTree.parent.sourceBoundary.uiHost,t=e&&this.settings.welcomeContextsUpRoot?e.rootBoundary.outerContexts:{};this.services.onContextPass(t)}void 0!==e.onlyRunInContainer&&e.onlyRunInContainer!==t&&this.refresh(!1,null,null)}getRootDomNode(){return this.rootBoundary&&this.rootBoundary.treeNode.domNode}getRootDomNodes(e=!0){return this.rootBoundary?r.rootDomTreeNodes(this.rootBoundary.treeNode,e,!1).map((e=>e.domNode)):[]}queryDomElement(e,t=!1){return r.domElementByQuery(this.groundedTree,e,!0,t)}queryDomElements(e,t=0,o=!1){return r.domElementsByQuery(this.groundedTree,e,t,!0,o)}findDomNodes(e=0,t=!1,o){return r.treeNodesWithin(this.groundedTree,{dom:!0},e,!0,t,o).map((e=>e.domNode))}findBoundaries(e=0,t=!1,o){return r.treeNodesWithin(this.groundedTree,{boundary:!0},e,!0,t,o).map((e=>e.boundary))}findTreeNodes(e,t=0,o=!1,s){return r.treeNodesWithin(this.groundedTree,e&&n.buildRecordable(e),t,!0,o,s)}static modifySettings(e,t){if(t.updateLiveModes)for(const o in t.updateLiveModes){const n=t.updateLiveModes[o];'string'==typeof n&&(e.updateLiveModes[o]=n)}for(const o in t){const n=t[o],s=typeof n;null!==n&&'boolean'!==s&&'string'!==s&&'number'!==s||(e[o]=n)}}static getDefaultSettings(e){const t={updateTimeout:0,renderTimeout:0,uiDidImmediateCalls:!1,callRefMoveEvenIfNoDomMove:!1,shouldUpdateWithNothing:!1,updateMiniMode:'shallow',updateLiveModes:{props:'shallow',state:'shallow',remote:'shallow',children:'changed'},preEqualCheckDomProps:!0,onlyRunInContainer:!1,welcomeContextsUpRoot:!0,wideKeysInArrays:!1,reuseSiblingTags:!0,noRenderValuesMode:!1,maxReRenders:1,renderTextTag:'',renderHtmlDefTag:'span',renderTextContent:null,renderSvgNamespaceURI:'http://www.w3.org/2000/svg',renderDomPropsOnSwap:!0,duplicateDomNodeBehaviour:'deep',duplicateDomNodeHandler:null,devLogWarnings:!1,devLogRenderInfos:!1,devLogCleanUp:!1};if(e)for(const o in e)t[o]=e[o];return t}}).UI_DOM_TYPE='Host',t}class W extends(k(Object)){}const H=(e,t,o)=>new W(e,t,o),L=k;class j{constructor(e){this.uiContext=e,this.pendingTimer=null,this.pendingKeys=null,this.mainActions=null,this.postActions=null,this.dirtyOrder=0}sendAction(e,t,o){if(!e.type)return;let n=this.preHandleAction(e);const s=this.uiContext.settings;'cancel'!==n&&(t&&(n=t),'post'===n||s.postActions&&s.postActions.has(e.type)?(this.postActions||(this.postActions=[]),this.postActions.push(e)):'quick'===n||!0===s.quickActions||s.quickActions&&s.quickActions.has(e.type)?this.runAction(e):(this.mainActions||(this.mainActions=[]),this.mainActions.push(e))),this.applyRefresh(s.refreshTimeout,o)}askQuestion(e,t=0){this.preHandleAction(e,!0),this.runAction(e,null,!0,t)}applyRefresh(e,t){this.pendingTimer=n.refreshWithTimeout(this,this.refreshPending,this.pendingTimer,e,t)}refreshPending(){let e=this.mainActions,t=this.postActions;const o=this.pendingKeys;this.pendingTimer=null,this.pendingKeys=null,this.mainActions=null,this.postActions=null;const n=new Set,s=t?n:null;if(e)for(const t of e)this.runAction(t,s);if(o&&this.runData(o,s),t){for(const e of[...n])if(e.services.hasPending()){const t=[e],o=this.onHostRender.bind(this,t);t.push(o),e.services.addListener('render',o)}else n.delete(e);this.delayedActions||(this.delayedActions=[]),this.delayedActions.push([n,t]),n.size||this.onHostRender()}}onHostRender(e){let t=null;e&&(t=e[0],t.services.removeListener('render',e[1]));const o=this.delayedActions;if(!o)return;let n=-1;for(const[e,s]of[...o])if(n++,t&&e.delete(t),!e.size){o.splice(n--,1);for(const e of s)this.runAction(e)}o[0]||delete this.delayedActions}addRefreshKeys(e){if(!0===e)this.pendingKeys=!0;else if(e&&!0!==this.pendingKeys)if('string'==typeof e&&(e=[e]),this.pendingKeys)for(const t of e)-1===this.pendingKeys.indexOf(t)&&this.pendingKeys.push(t);else this.pendingKeys=[...e]}runData(t,o){const n=this.uiContext;let s=n.dataBoundaries;this.dirtyOrder&e.Data&&s.size>1&&(n.dataBoundaries=s=j.sortCollection(s)),this.dirtyOrder&=~e.Data;for(const[e,n]of s){o&&o.add(e.uiHost);for(const o of n){let n=!0===t;if(!n){const s=e.contextApi.contextNeeds.get(o);if(!0===s)n=!0;else if(s)for(const e of t)if(s.some((t=>t===e||t.startsWith(e+'.')))){n=!0;break}}if(n){e.uiHost.services.absorbUpdates(e,{contextual:!0});break}}}if(n.dataListeners.size)for(const[e,o]of n.dataListeners){let s=!1;if(!0===o||!0===t)s=!0;else{const e=[...o];for(const o of t)if(e.some((e=>e===o||e.startsWith(o+'.')))){s=!0;break}}s&&e(n.data,n)}}runAction(t,o,n,s){if(!t.type)return;const i=this.uiContext;let r=i.actionBoundaries;this.dirtyOrder&e.Actions&&(r.size>1&&(i.actionBoundaries=r=j.sortCollection(r)),this.dirtyOrder&=~e.Actions);const d=t;for(const[e,a]of r){const r=e.contextApi.actionNeeds,c=e.live;o&&o.add(e.uiHost);for(const e of a){const o=r.get(e);if(o&&(!0===o||o.has(t.type)))if(n){if(c.uponQuestion){if(d.value=c.uponQuestion(d,i,e),!d.values)return;const t=d.values.push(d.value);if(s&&t>=s)return}}else c.uponAction&&c.uponAction(t,i,e)}}for(const[e,o]of i.actionListeners)if(o&&(!0===o||o.has(t.type)))if(n){if(d.value=e(d,i),!d.values)return;const t=d.values.push(d.value);if(s&&t>=s)return}else e(t,i)}preHandleAction(e,t=!1){let o='';const n=this.uiContext;for(const[s,i]of n.actionHandlers)if(!0===i||i.has(e.type||''))if(t)s(e,n);else{const t=s(e,n);!t||o&&('cancel'===o||'post'===o&&'cancel'!==t)||(o=t)}return o}static flagActions(e,t,o,n=!0){if(null===o||!0===o)e[t]=o;else{const s='string'==typeof o?[o]:o,i=e[t];if(n&&i&&!0!==i)for(const e of s)i.add(e);else e[t]=new Set(s)}}onInterest(t,o,n){const s='data'===t,i=s?this.uiContext.dataBoundaries:this.uiContext.actionBoundaries,r=i.get(o);r?r.add(n):i.set(o,new Set([n])),this.dirtyOrder|=s?e.Data:e.Actions;const d=s?'onDataInterests':'onActionInterests';this.uiContext[d]&&this.uiContext[d](o,n,!0)}onDisInterest(e,t,o){const n='data'===e,s=n?'onDataInterests':'onActionInterests';this.uiContext[s]&&this.uiContext[s](t,o,!1);const i=n?this.uiContext.dataBoundaries:this.uiContext.actionBoundaries,r=i.get(t);r&&(r.delete(o),r.size||i.delete(t))}onBoundaryMove(t,o){const n=t.contextApi;this.dirtyOrder|=(n.actionNeeds.get(o)&&e.Actions||0)|(n.contextNeeds.get(o)&&e.Data||0)}static sortCollection(e){const t=[...e.keys()];return P.sortBoundaries(t),new Map(t.map((t=>[t,e.get(t)])))}}function F(e){var t;return(t=class extends e{constructor(e,t,...o){super(...o),this.inTree=new Map,this.dataBoundaries=new Map,this.actionBoundaries=new Map,this.dataListeners=new Map,this.actionListeners=new Map,this.actionHandlers=new Map,this.data=e,this.settings={postActions:null,quickActions:null,refreshTimeout:0},this.services=new j(this),t&&this.modifySettings(t)}modifySettings(e){void 0!==e.postActions&&j.flagActions(this.settings,'postActions',e.postActions,!1),void 0!==e.quickActions&&j.flagActions(this.settings,'quickActions',e.quickActions,!1),void 0!==e.refreshTimeout&&(this.settings.refreshTimeout=e.refreshTimeout)}flagPostActions(e,t=!0){j.flagActions(this.settings,'postActions',e,t)}flagQuickActions(e,t=!0){j.flagActions(this.settings,'quickActions',e,t)}addActionHandler(e,t=!0){this.actionHandlers.set(e,'object'!=typeof t||new Set('string'==typeof t?[t]:t))}removeActionHandler(e){this.actionHandlers.delete(e)}addActionListener(e,t=!0){this.actionListeners.set(e,'string'==typeof t?new Set([t]):'object'!=typeof t||new Set(t))}removeActionListener(e){this.actionListeners.delete(e)}addDataListener(e,t=!0){this.dataListeners.set(e,'string'==typeof t?new Set([t]):'object'!=typeof t||new Set(t))}removeDataListener(e){this.dataListeners.delete(e)}sendAction(e,t,o){this.services.sendAction(e,t,o)}sendActionWith(e,t,o,n){this.services.sendAction({type:e,payload:t},o,n)}askQuestion(e,t){return void 0===e.value&&(e.value=t),this.services.askQuestion(e,1),e.value}askQuestionWith(e,t,o){const n={type:e,payload:t,value:o};return this.services.askQuestion(n,1),n.value}askQuestionary(e,t=0){return e.values=[],this.services.askQuestion(e,t),e.values}askQuestionaryWith(e,t,o=0){const n={type:e,payload:t,values:[]};return this.services.askQuestion(n,o),n.values}setData(e,t=!1,o=!0,n){this.data=t&&this.data&&this.data.constructor===Object?Object.assign(Object.assign({},this.data),e):e,o&&this.refresh(!0,n)}setInData(e,t,o=!1,n=!0,s){const i=e.split('.'),r=i.pop();if(!r||!this.data)return;let d=this.data;for(const e of i)d=i[e];if(o){const e=d[r];e&&e.constructor===Object?d[r]=Object.assign(Object.assign({},e),t):o=!1}o||(d[r]=t),n&&this.refresh(e,s)}getData(){return this.data}getInData(e){const t=e.split('.');let o=this.data;for(const e of t)o=o[e];return o}refresh(e,t){e&&this.services.addRefreshKeys(e),this.services.applyRefresh(this.settings.refreshTimeout,t)}}).UI_DOM_TYPE='Context',t}class Y extends(F(Object)){constructor(e,t){super(e,t)}}const q=(e,t)=>new Y(e,t),Q=F;class z{constructor(e){}}z.UI_DOM_TYPE='Contexts';const K=e=>{const t={};for(const o in e)t[o]=q(e[o]);return t};function G(e){var t;return(t=class extends e{constructor(e,t,...o){super(...o),this.memory=t,this.onMount=e||null,this.onUnmount=null,this.depth=1}setDepth(e){this.depth=null==e?1:'string'==typeof e?o[e]:e}reset(e,t,o=!1){return this.use(t,o,e)}use(e,t=!1,o){const s=this.memory;return!t&&this.depth>-2&&n.areEqual(s,e,this.depth)||(this.memory=e,void 0!==o&&(this.onUnmount&&this.onUnmount(s,e,'use'),this.onUnmount=null,this.onMount=o),this.onMount&&(this.onUnmount=this.onMount(s,e)||null)),!1}cancel(e=!1,t=!1){!e&&this.onUnmount&&this.onUnmount(this.memory,this.memory,'cancel'),t&&(this.onMount=null,this.onUnmount=null)}}).UI_DOM_TYPE='Effect',t}class V extends(G(Object)){}const J=(e,t)=>new V(e,t),X=G,Z=(e,t,s=1)=>{let i,r=[];return s='string'==typeof s?o[s]:s,(...o)=>{const d=e(...o);return s>=-1&&n.areEqual(d,r,s)||(r=d,i=t(...r)),i}},$=(e,t,o=1)=>Z(((...t)=>e.map((e=>e&&e(...t)))),t,o),ee=i.createDef,te=i.newContentPassDef(),oe=i.newContentPassDef({},!0),ne=(...e)=>i.createDef(se.Fragment,{needsChildren:!0},...e),se={Host:W,HostMixin:L,Live:T,LiveMixin:_,Mini:g,MiniMixin:v,Ref:f,RefMixin:m,Context:Y,ContextMixin:Q,ContextAttach:t,Effect:V,EffectMixin:X,createEffect:J,createDataPicker:Z,createDataSelector:$,Contexts:z,Fragment:d,Portal:a,Element:c,Content:te,withContent:ne,ContentCopy:oe,copyContent:i.newContentCopyDef,create:H,createHost:H,createContext:q,createContexts:K,createRef:p,createSpread:l,spread:l,createLive:b,live:b,createLiveBy:B,liveBy:B,createMini:D,mini:D,createWired:x,wired:x,createDef:i.createDef,def:i.createDef,htmlDef:(e,t,o,s)=>{const i={_uiDefType:'content',tag:t||'',childDefs:[],domContent:e,domHtmlMode:!0};return t&&o&&(i.props=n.cleanHtmlProps(o)),null!=s&&(i.key=s),i},findTreeNodesIn:(e,t,o=0,s,i,d)=>r.treeNodesWithin(e,n.buildRecordable(t),o,s,i,d),findBoundariesIn:(e,t=0,o,n,s)=>r.treeNodesWithin(e,{boundary:!0},t,o,n,s).map((e=>e.boundary)),findDomNodesIn:(e,t=0,o,n,s)=>r.treeNodesWithin(e,{dom:!0},t,o,n,s).map((e=>e.domNode)),queryDomElementIn:(e,t,o,n)=>r.domElementByQuery(e,t,o,n),queryDomElementsIn:(e,t,o=0,n,s)=>r.domElementsByQuery(e,t,o,n,s),classNames:n.cleanHtmlClass,parseStyle:n.cleanHtmlStyle,areEqual:n.areEqual,range:n.range};export{o as UICompareDepthByMode,Y as UIContext,t as UIContextAttach,Q as UIContextMixin,e as UIContextRefresh,z as UIContexts,se as UIDom,V as UIEffect,X as UIEffectMixin,c as UIElement,d as UIFragment,W as UIHost,L as UIHostMixin,T as UILive,_ as UILiveMixin,g as UIMini,v as UIMiniMixin,a as UIPortal,f as UIRef,m as UIRefMixin,S as UISourceBoundary,u as UISpread,C as UIWired,q as createContext,K as createContexts,Z as createDataPicker,$ as createDataSelector,J as createEffect,H as createHost,b as createLive,D as createMini,p as createRef,l as createSpread,x as createWired,te as uiContent,oe as uiContentCopy,ee as uiDef,se as uiDom,ne as uiWithContent};
